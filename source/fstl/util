// ---------------------------------------------------------------------------------------------------------------------------------
//        _   _ _
//       | | (_) |
//  _   _| |_ _| |
// | | | | __| | |
// | |_| | |_| | |
//  \__,_|\__|_|_|
//
//
//
// Description:
//
//   Miscellaneous utilitarian functions
//
// Notes:
//
//   Best viewed with 8-character tabs and (at least) 132 columns
//
// History:
//
//   04/13/2001 by Paul Nettle: Original creation
//
// ---------------------------------------------------------------------------------------------------------------------------------
// Originally released under a custom license.
// This historical re-release is provided under the MIT License.
// See the LICENSE file in the repo root for details.
//
// https://github.com/nettlep
//
// Copyright 2002, Fluid Studios, all rights reserved.
// ---------------------------------------------------------------------------------------------------------------------------------

#ifndef	_FSTL_UTIL
#define _FSTL_UTIL

// ---------------------------------------------------------------------------------------------------------------------------------
// Module setup (required includes, macros, etc.)
// ---------------------------------------------------------------------------------------------------------------------------------

#include <new>
#include "common"

FSTL_NAMESPACE_BEGIN

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	T	pi()
{
	return static_cast<T>(3.14159265359);
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	T	toRadians(const T & a)
{
	return pi<T>() / static_cast<T>(180) * a;
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	T	toDegrees(const T & a)
{
	return static_cast<T>(180) / pi<T>() * a;
}

// ---------------------------------------------------------------------------------------------------------------------------------

#ifdef	min
#undef	min
#endif

template <class T>
inline	T &	min(T & a, T & b)
{
	return (a < b) ? a : b;
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	const T &	min(const T & a, const T & b)
{
	return (a < b) ? a : b;
}

// ---------------------------------------------------------------------------------------------------------------------------------

#ifdef	max
#undef	max
#endif

template <class T>
inline	T &	max(T & a, T & b)
{
	return (a > b) ? a : b;
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	const T &	max(const T & a, const T & b)
{
	return (a > b) ? a : b;
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	T	abs(const T & a)
{
	return (a < 0) ? -a : a;
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	void	swap(T& a, T& b)
{
	T c(a);
	a = b;
	b = c;
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	T *	allocate(const unsigned int count)
{
	T *	ptr = static_cast<T *>(operator new(sizeof(T) * count));
	#ifdef	UNICODE
	if (!ptr) throwstring(_T(""), _T("Out of memory"));
	#else
	#ifndef _LINUX
	if (!ptr) throwstring("", "Out of memory");
	#else
	if (!ptr) throw "Out of memory";
	#endif
	#endif
	return	ptr;
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	void	deallocate(T* ptr)
{
	operator delete(ptr);
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	T *	construct(T* ptr)
{
	return new (static_cast<void *>(ptr)) T;
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T, class Tz>
inline	T *	construct(T* ptr, Tz &src)
{
	return new (static_cast<void *>(ptr)) T(src);
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	void	destruct(T* ptr)
{
	if (ptr) ptr->~T();
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	void	destructElements(T* ptr, const unsigned int count)
{
	for (unsigned int i = 0; i < count; ++i)
	{
		destruct(&ptr[i]);
	}
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	void	moveElements(T* dst, T* src, const unsigned int count)
{
	// Supposed to be doing anything?

	if (!count) return;

	// Copying forward or backwards?
	
	if (dst < src)
	{
		for (unsigned int i = 0; i < count; ++i, ++dst, ++src)
		{
			*dst = *src;
		}
	}
	else
	{
		T*	s = src + count - 1;
		T*	d = dst + count - 1;
		for (unsigned int i = 0; i < count; ++i, --d, --s)
		{
			*d = *s;
		}
	}
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	void	copyElements(T* dst, T* src, const unsigned int count)
{
	// Supposed to be doing anything?

	if (!count) return;

	for (unsigned int i = 0; i < count; ++i, ++dst, ++src)
	{
		construct(dst, *src);
	}
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	void	fillElements(T* dst, const T& src, const unsigned int count)
{
	for (unsigned int i = 0; i < count; ++i, ++dst)
	{
		*dst = src;
	}
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	void	invertElements(T* ptr, const unsigned int count)
{
	T *	p0 = ptr;
	T *	p1 = ptr + count - 1;

	while(p0 < p1)
	{
		swap(*p0, *p1);
		++p0;
		--p1;
	}
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	T	toupper(T& c)
{
	return (c >= static_cast<T>('a') && c <= static_cast<T>('z')) ? (c - static_cast<T>('a'-'A')):c;
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	T	tolower(T& c)
{
	return (c >= static_cast<T>('A') && c <= static_cast<T>('Z')) ? (c + static_cast<T>('a'-'A')):c;
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	bool	isspace(T c)
{
	return	(c == static_cast<T>(' ' )) ||
		(c == static_cast<T>('\t')) ||
		(c == static_cast<T>('\v')) ||
		(c == static_cast<T>('\r')) ||
		(c == static_cast<T>('\n')) ||
		(c == static_cast<T>('\f'));
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	bool	isdigit(T c)
{
	return (c >= static_cast<T>('0')) && (c <= static_cast<T>('9'));
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	bool	isalpha(T c)
{
	return	(c >= static_cast<T>('a') && c <= static_cast<T>('z')) ||
		(c >= static_cast<T>('A') && c <= static_cast<T>('Z'));
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	bool	isalnum(T c)
{
	return isalpha(c) || isdigit(c);
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	void	zeromem(T* dst, unsigned int count = 1)
{
	::memset(dst, 0, sizeof(T) * count);
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	void	memset(T* dst, T fill, unsigned int count)
{
	if (sizeof(T) == 1)
	{
		::memset(dst, fill, count);
	}
	else
	{
		while(count--) *(dst++) = fill;
	}
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	void	memcpy(T* dst, const T* src, unsigned int count)
{
	::memcpy(dst, src, sizeof(T) * count);
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	void	memmove(T* dst, const T* src, unsigned int count)
{
	::memmove(dst, src, sizeof(T) * count);
}

// ---------------------------------------------------------------------------------------------------------------------------------

template <class T>
inline	T	rand(const T min, const T max)
{
	double	result = static_cast<double>(::rand()) / static_cast<double>(RAND_MAX) * static_cast<double>(max-min) + static_cast<double>(min);
	return	static_cast<T>(result);
}

// ---------------------------------------------------------------------------------------------------------------------------------
// Wide-char low-level specialization routines
// ---------------------------------------------------------------------------------------------------------------------------------

inline	int		atoi(const char * str)						{return ::atoi(str);}
#ifndef	_LINUX
inline	int		atoi(const wchar_t * str)					{return ::_wtoi(str);}
#endif

inline	long		atol(const char * str)						{return ::atol(str);}
#ifndef	_LINUX
inline	long		atol(const wchar_t * str)					{return ::_wtol(str);}
#endif

inline	double		atof(const char * str)						{return ::atof(str);}
#ifndef	_LINUX
inline	double		atof(const wchar_t * str)					{return ::_wtof(str);}
#endif

inline	size_t		strlen(const char * a)						{return ::strlen(a);}
#ifndef	_LINUX
inline	size_t		strlen(const wchar_t * a)					{return ::wcslen(a);}
#endif

inline	char *		strcpy(char * a, const char * b)				{return ::strcpy(a,b);}
#ifndef	_LINUX
inline	wchar_t *	strcpy(wchar_t * a, const wchar_t * b)				{return ::wcscpy(a,b);}
#endif

inline	char *		strncpy(char * a, const char * b, size_t c)			{return ::strncpy(a,b,c);}
#ifndef	_LINUX
inline	wchar_t *	strncpy(wchar_t * a, const wchar_t * b, size_t c)		{return ::wcsncpy(a,b,c);}
#endif

inline	int		strcmp(const char * a, const char * b)				{return ::strcmp(a,b);}
#ifndef	_LINUX
inline	int		strcmp(const wchar_t * a, const wchar_t * b)			{return ::wcscmp(a,b);}
#endif

inline	int		strncmp(const char * a, const char * b, size_t c)		{return ::strncmp(a,b,c);}
#ifndef	_LINUX
inline	int		strncmp(const wchar_t * a, const wchar_t * b, size_t c)		{return ::wcsncmp(a,b,c);}
#endif

#ifndef	_LINUX
inline	int		stricmp(const char * a, const char * b)				{return ::stricmp(a,b);}
inline	int		stricmp(const wchar_t * a, const wchar_t * b)			{return ::wcsicmp(a,b);}
#else
inline	int		stricmp(const char * a, const char * b)				{return ::strcasecmp(a,b);}
#endif

#ifndef	_LINUX
inline	int		strnicmp(const char * a, const char * b, size_t c)		{return ::strnicmp(a,b,c);}
inline	int		strnicmp(const wchar_t * a, const wchar_t * b, size_t c)	{return ::wcsnicmp(a,b,c);}
#else
inline	int		strnicmp(const char * a, const char * b, size_t c)		{return ::strncasecmp(a,b,c);}
#endif

inline	const char *strstr(const char * a, const char * b)				{return ::strstr(a,b);}
#ifndef	_LINUX
inline	const wchar_t *strstr(const wchar_t * a, const wchar_t * b)			{return ::wcsstr(a,b);}
#endif

inline	const char *strchr(const char * a, int b)					{return ::strchr(a,b);}
#ifndef	_LINUX
inline	const wchar_t *strchr(const wchar_t * a, int b)				{return ::wcschr(a,b);}
#endif

inline	size_t		strcspn(const char * a, const char * b)				{return ::strcspn(a,b);}
#ifndef	_LINUX
inline	size_t		strcspn(const wchar_t * a, const wchar_t * b)			{return ::wcscspn(a,b);}
#endif

inline	size_t		strspn(const char * a, const char * b)				{return ::strspn(a,b);}
#ifndef	_LINUX
inline	size_t		strspn(const wchar_t * a, const wchar_t * b)			{return ::wcsspn(a,b);}
#endif

template<class T> T	space_char()							{return static_cast<T>(' ');}
template<class T> T *	empty_string()							{static	T nullchar; return &nullchar;}

FSTL_NAMESPACE_END
#endif // _FSTL_UTIL
// ---------------------------------------------------------------------------------------------------------------------------------
// util - End of file
// ---------------------------------------------------------------------------------------------------------------------------------

