// ---------------------------------------------------------------------------------------------------------------------------------
//  _               _
// | |             | |
// | |__   __ _ ___| |__
// | '_ . / _` / __| '_ .
// | | | | (_| .__ . | | |
// |_| |_|.__,_|___/_| |_|
//
// Description:
//
//   Generic hash table
//
// Notes:
//
//   Best viewed with 8-character tabs and (at least) 132 columns
//
// History:
//
//   04/13/2001 by Paul Nettle: Original creation
//
// ---------------------------------------------------------------------------------------------------------------------------------
// Originally released under a custom license.
// This historical re-release is provided under the MIT License.
// See the LICENSE file in the repo root for details.
//
// https://github.com/nettlep
//
// Copyright 2002, Fluid Studios, all rights reserved.
// ---------------------------------------------------------------------------------------------------------------------------------

#ifndef	_FSTL_HASH
#define _FSTL_HASH

// ---------------------------------------------------------------------------------------------------------------------------------
// Module setup (required includes, macros, etc.)
// ---------------------------------------------------------------------------------------------------------------------------------

#include "common"
#include "list"
#include "array"

FSTL_NAMESPACE_BEGIN

// ---------------------------------------------------------------------------------------------------------------------------------

template<class T, unsigned int S = 1024, unsigned int G = 2>
class	hash
{
private:
	class	node
	{
	public:
	inline				node() : _id(0) {}
	inline				~node() {}
	inline	const	unsigned int	id() const {return _id;}
	inline  	unsigned int &	id() {return _id;}
	inline  const	T &		data() const {return _data;}
	inline  	T &		data() {return _data;}
	
	private:
			unsigned int	_id;
			T		_data;
	};
public:
	// Construction/Destruction

inline	        		hash()
				: _size(0)
				{
					erase();
				}

inline	        		hash(hash & rhs)
				: _size(0)
				{
					*this = rhs;
				}

virtual				~hash() {}

	// Operators

inline		hash &		operator =(const hash & h)
				{
					if (this == &h) return *this;
					
					// This is simple...
					
					_table = h._table;
					_size = h._size;

					return *this;
				}

inline		T &		operator [](const unsigned int id)
				{
					return get(id);
				}

	// Implementation

inline		void		erase()
				{
					// Erase anything in the table

					_table.erase();

					// Set the reserve

					_table.reserve(S);

					// Populate the table with "blanks"

					list<node,G>	temp;
					for (unsigned int i = 0; i < hashSize(); ++i)
					{
						_table.insert(temp);
					}

					// Size is now zero

					_size = 0;
				}

inline		T &		get(const unsigned int id)
				{
					// Go find this node in the hash
					
					list<node,G> &		l = locateList(id);
					typename list<node,G>::node *	n = locateNode(l, id);
					
					// Found?

					if (n) return n->data().data();
					
					// Not found, insert one

					++_size;
					node	temp;
					temp.id() = id;
					return l.insert(temp)->data().data();
				}
				
inline		bool		remove(const unsigned int id)
				{
					// Go find this node in the hash
					
					list<node,G> &		l = locateList(id);
					typename list<node,G>::node *	n = locateNode(l, id);

					// Not found?

					if (!n) return false;
					
					// Remove it

					--_size;
					l.erase(n,1);
					return true;
				}

inline		bool		exist(const unsigned int id)
				{
					list<node,G> &		l = locateList(id);
					typename list<node,G>::node *	n = locateNode(l, id);
					return n ? true:false;
				}

	// Accessors

inline		unsigned int	size() const {return _size;}
inline		unsigned int	hashSize() const {return S;}

private:
	// Utilitarian (private)

inline		unsigned int	hashIndex(const unsigned int id) const
				{
					return id % hashSize();
				}

inline		list<node,G> &	locateList(const unsigned int id)
				{
					// Using the index, lookup the hash table entry list

					return _table[hashIndex(id)];
				}
				
inline		typename list<node,G>::node * locateNode(list<node,G> & l, const unsigned int id)
				{
					// Scan the given list for a node with the given id

					typename list<node,G>::node * ptr = l.head();
					while(ptr)
					{
						if (ptr->data().id() == id) return ptr;
						ptr = ptr->next();
					}

					// Not found, return null

					return static_cast<typename list<node, G>::node *>(0);
				}
	// The hash table

		unsigned int		_size;
		array<list<node,G> >	_table;
};

// ---------------------------------------------------------------------------------------------------------------------------------
// These are handy...
// ---------------------------------------------------------------------------------------------------------------------------------

typedef	hash<bool>		boolHash;
typedef	hash<int>		intHash;
typedef	hash<unsigned int>	uintHash;
typedef	hash<char>		charHash;
typedef	hash<unsigned char>	ucharHash;
typedef	hash<short>		shortHash;
typedef	hash<unsigned short>	ushortHash;
typedef	hash<float>		floatHash;
typedef	hash<double>		doubleHash;

FSTL_NAMESPACE_END
#endif // _FSTL_HASH
// ---------------------------------------------------------------------------------------------------------------------------------
// hash - End of file
// ---------------------------------------------------------------------------------------------------------------------------------
